"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var block_exports = {};
__export(block_exports, {
  Block: () => Block,
  matcher: () => matcher
});
module.exports = __toCommonJS(block_exports);
var import_index = require("./index.js");
var import_utils = require("./utils.js");
const matcher = {
  msgid: /^(msgid(?!_))(.*)/,
  msgstr: /^(msgstr(?:\[\d+])?)\s+(.*)/,
  // msgstr or msgstr[0]
  msgctxt: /^(msgctxt)\s+(.*)/,
  msgid_plural: /^(msgid_plural)\s+(.*)/,
  extracted: /^(#\.)(.*)/,
  reference: /^(#:)\s+(.*)/,
  flag: /^(#(?:[^:.,|]|$))\s+(.*)/,
  previous: /^(#\|)\s+(.*)/,
  translator: /^(#(?![.:,|]))\s+(.*)/
  // OK, I'm lazy! Anyway, this will catch all "#" stuff that is not #. #: #, or #|
};
const _Block = class _Block {
  /**
   * Constructor for initializing the message properties from the given lines.
   *
   * @param {string | string[] | Partial<Block>} data - The array of strings containing the message lines.
   */
  constructor(data) {
    if (typeof data === "string")
      data = data.split("\n");
    if (Array.isArray(data)) {
      this.parseBlock(data);
    } else if (typeof data === "object") {
      for (const key in data) {
        if (typeof this[key] !== null) {
          this[key] = data[key];
        }
      }
    }
  }
  parseBlock(lines) {
    var _a, _b;
    if (!lines.length)
      return void 0;
    let currentType;
    let rawBlock = {};
    lines.forEach((line) => {
      if (!line)
        return;
      if (line.startsWith('"')) {
        currentType = currentType || "msgid";
        rawBlock[currentType] = rawBlock[currentType] || [];
        rawBlock[currentType].push(line.unquote());
      } else {
        for (const type in matcher) {
          const regexResult = matcher[type].exec(line.unquote());
          if (regexResult) {
            currentType = type;
            if (!rawBlock[type]) {
              rawBlock[type] = [];
            }
            rawBlock[type].push(regexResult[2].trim().unquote());
            break;
          }
        }
      }
    });
    Object.assign(this, {
      msgid: rawBlock.msgid.join('"\n"') || "",
      msgid_plural: (_a = rawBlock.msgid_plural) == null ? void 0 : _a.join("\n"),
      msgstr: rawBlock.msgstr || [],
      msgctxt: (_b = rawBlock.msgctxt) == null ? void 0 : _b.join("\n"),
      comments: {
        translator: rawBlock == null ? void 0 : rawBlock.translator,
        extracted: rawBlock == null ? void 0 : rawBlock.extracted,
        reference: rawBlock == null ? void 0 : rawBlock.reference,
        flag: rawBlock == null ? void 0 : rawBlock.flag,
        previous: rawBlock == null ? void 0 : rawBlock.previous
      }
    });
  }
  /**
   * Map an array of strings to a string representation.
   *
   * @param strings array of strings
   * @param prefix string prefix for each line
   */
  mapStrings(strings = [], prefix = "# ") {
    return strings.length ? strings == null ? void 0 : strings.map((line) => prefix + line).join("\n") : void 0;
  }
  /**
   * Extracts a multi-line string from an array of strings.
   *
   * @param msgstr
   * @param prefix
   */
  extractMultiString(msgstr, prefix = "msgstr") {
    if (msgstr.length > 1) {
      return msgstr.map(
        (line, index) => `${prefix}${msgstr.length > 1 ? "[" + index + "]" : ""} "${(0, import_utils.splitMultiline)(line)}"`
      ).join("\n");
    } else if (msgstr.length === 1) {
      return `${prefix} "${msgstr[0]}"`;
    }
    return `${prefix} ""`;
  }
  /**
   * Converts the object to a string representation.
   *
   * @return {string} The string representation of the object.
   */
  toStr() {
    const { comments, msgid, msgid_plural, msgstr, msgctxt } = this;
    const res = [
      this.mapStrings(comments == null ? void 0 : comments.translator),
      // Add key for translator comments
      this.mapStrings(comments == null ? void 0 : comments.extracted, "#. "),
      // Add key for extracted comments
      this.mapStrings(comments == null ? void 0 : comments.reference, "#: "),
      // Add key for reference comments
      (comments == null ? void 0 : comments.flag) ? `#, ${comments.flag}` : void 0,
      // Add key for flag comments
      this.mapStrings(comments == null ? void 0 : comments.previous, "#| "),
      // Add key for previous comments
      msgctxt ? `msgctxt "${msgctxt}"` : void 0,
      // Add key for msgctxt
      msgid ? `msgid "${(0, import_utils.splitMultiline)(msgid)}"` : 'msgid ""',
      // Add key for msgid even if it's empty
      msgid_plural ? `msgid_plural "${msgid_plural}"` : void 0,
      // Add key for msgid_plural
      msgstr ? this.extractMultiString(msgstr) : 'msgstr ""'
      // Add keys for msgstr even if it's empty
    ].filter(Boolean).filter((line) => line == null ? void 0 : line.length);
    return res.join("\n");
  }
  toJson() {
    var _a, _b, _c, _d;
    const { comments, msgid = "", msgid_plural, msgstr = [], msgctxt = "" } = this;
    return {
      msgctxt,
      msgid,
      msgid_plural,
      msgstr,
      comments: {
        translator: ((_a = comments == null ? void 0 : comments.translator) == null ? void 0 : _a.join("\n")) || "",
        extracted: ((_b = comments == null ? void 0 : comments.extracted) == null ? void 0 : _b.join("\n")) || "",
        reference: ((_c = comments == null ? void 0 : comments.reference) == null ? void 0 : _c.join("\n")) || "",
        flag: (comments == null ? void 0 : comments.flag) || "",
        previous: ((_d = comments == null ? void 0 : comments.previous) == null ? void 0 : _d.join("\n")) || ""
      }
    };
  }
  /**
   * Generates a hash value for the concatenation of msgctxt, msgid, and msgid_plural.
   *
   * @return {number} the hash value generated
   */
  hash() {
    const strToHash = (this.msgctxt || "") + "|" + (this.msgid || "");
    let hash = 2166136261;
    for (let i = 0; i < strToHash.length; i++) {
      hash ^= strToHash.charCodeAt(i);
      hash *= 16777619;
    }
    return hash >>> 0;
  }
  /**
   * Merges the other block with the current block.
   */
  merge(other) {
    if (this.msgid === other.msgid) {
      this.msgid_plural = this.msgid_plural || other.msgid_plural;
      this.msgctxt = this.msgctxt || other.msgctxt;
      this.msgstr = this.msgstr || other.msgstr;
      this.comments = (0, import_index.mergeComments)(this.comments, other.comments);
    }
  }
};
__name(_Block, "Block");
let Block = _Block;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Block,
  matcher
});

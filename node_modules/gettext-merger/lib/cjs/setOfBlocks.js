"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var setOfBlocks_exports = {};
__export(setOfBlocks_exports, {
  SetOfBlocks: () => SetOfBlocks
});
module.exports = __toCommonJS(setOfBlocks_exports);
var import_utils = require("./utils.js");
const _SetOfBlocks = class _SetOfBlocks {
  /**
   * Constructor for the Block class.
   *
   * @param {Block[]} arr - optional array of Block objects
   * @param path - optional path to the file
   */
  constructor(arr, path) {
    this.blocks = arr || [];
    this.path = path || void 0;
  }
  /**
   * Add a block to the collection, merging if a duplicate exists.
   *
   * @param {Block} block - the block to add
   * @return {void}
   */
  add(block) {
    const duplicate = this.getDuplicate(block.hash());
    if (duplicate) {
      duplicate.merge(block);
    } else {
      this.blocks.push(block);
    }
  }
  /**
   * Find and return a duplicate block based on the given hash.
   *
   * @param {number} hash - the hash to search for
   * @return {Block | undefined} the duplicate block, if found
   */
  getDuplicate(hash) {
    for (let i = 0; i < this.blocks.length; i++) {
      if (this.blocks[i].hash() === hash) {
        return this.blocks[i];
      }
    }
    return void 0;
  }
  /**
   * Chainable sort function
   *
   * @param type - sorting type ('alphabetically', 'numerically', etc.)
   * @returns {SetOfBlocks} the instance of SetOfBlocks
   */
  sortBlocks(type = "alphabetically") {
    switch (type) {
      case "alphabetically":
        this.blocks.sort((a, b) => a.msgid.localeCompare(b.msgid));
        break;
      case "hash":
        this.blocks.sort(import_utils.hashCompare);
        break;
    }
    return this;
  }
  /**
   * Chainable filter function used to remove blocks without mandatory fields
   * Usually you want to fire this function to clean up the blocks without the msgid
   *
   * @returns {SetOfBlocks} the instance of SetOfBlocks
   */
  cleanup(mandatoryField = "msgid") {
    this.blocks = this.blocks.filter((b) => !!b[mandatoryField]);
    return this;
  }
  /**
   * Convert the blocks to a string representation.
   *
   * @return {string} the string representation of the blocks
   */
  toStr() {
    return this.blocks.reduce((prev, curr) => prev + curr.toStr() + "\n\n", "");
  }
  /**
   * Convert the blocks to a JSON representation using a compatible format for gettext-parser module
   *
   * @return {Map<string, Map<string, GetTextTranslation>>} the JSON representation of the blocks
   */
  toJson() {
    const jsonObject = {};
    this.blocks.forEach((block) => {
      const index = block.msgctxt || "";
      if (!jsonObject[index]) {
        jsonObject[index] = {};
      }
      jsonObject[index][block.msgid] = block.toJson();
    });
    return jsonObject;
  }
  /**
   * Adds an array of Block objects to the current instance.
   *
   * @param {Block[]} arr - The array of Block objects to add
   * @return {void}
   */
  addArray(arr) {
    for (const item of arr)
      this.add(item);
    this.blocks.filter((b) => b.msgid);
  }
};
__name(_SetOfBlocks, "SetOfBlocks");
let SetOfBlocks = _SetOfBlocks;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  SetOfBlocks
});

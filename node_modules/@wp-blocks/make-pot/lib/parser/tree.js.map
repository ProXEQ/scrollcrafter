{
  "version": 3,
  "sources": ["../../src/parser/tree.ts"],
  "sourcesContent": ["import Parser, { type SyntaxNode } from \"tree-sitter\";\r\nimport { i18nFunctions } from \"../const.js\";\r\n\r\nimport { Block, SetOfBlocks } from \"gettext-merger\";\r\nimport { getParser } from \"../fs/glob.js\";\r\nimport { reverseSlashes, stripTranslationMarkup } from \"../utils/common.js\";\r\nimport type { Args } from \"../types.js\";\r\n\r\n/**\r\n * Collect comments from the AST node and its preceding siblings.\r\n *\r\n * @param {SyntaxNode} node - The AST node.\r\n * @return {string[]} An array of collected comments.\r\n */\r\nfunction collectComments(node: SyntaxNode): string | undefined {\r\n\tlet currentNode = node;\r\n\tlet depth = 0;\r\n\r\n\t// Check the node's preceding siblings for comments\r\n\twhile (currentNode && depth < 6) {\r\n\t\tif (\r\n\t\t\tcurrentNode?.previousSibling?.type === \"comment\" &&\r\n\t\t\tcurrentNode?.previousSibling?.text.toLowerCase().includes(\"translators\")\r\n\t\t) {\r\n\t\t\treturn currentNode?.previousSibling?.text\r\n\t\t\t\t? stripTranslationMarkup(currentNode.previousSibling.text)\r\n\t\t\t\t: undefined;\r\n\t\t}\r\n\t\tdepth++;\r\n\t\tcurrentNode = currentNode.parent as SyntaxNode;\r\n\t}\r\n}\r\n\r\n/**\r\n * Parses the source code using the specified language parser and extracts the strings from the file.\r\n *\r\n * @param {string} sourceCode - The source code to be parsed.\r\n * @param {string} filepath - The path to the file being parsed.\r\n * @param {boolean} debugEnabled - Whether debug mode is enabled.\r\n * @param {Args} args - The command line arguments, optional.\r\n * @return {SetOfBlocks} An array of translation strings.\r\n */\r\nexport function doTree(\r\n\tsourceCode: string,\r\n\tfilepath: string,\r\n\tdebugEnabled?: boolean,\r\n\targs?: Args,\r\n): SetOfBlocks {\r\n\t// set up the parser\r\n\tconst parser = new Parser();\r\n\tconst parserExt = getParser(filepath);\r\n\t// if no parser is found return empty\r\n\tif (!parserExt) return new SetOfBlocks([], filepath);\r\n\t// set the parser language\r\n\tparser.setLanguage(parserExt);\r\n\r\n\t// set up the translation object\r\n\tconst gettextTranslations: SetOfBlocks = new SetOfBlocks([], filepath);\r\n\r\n\tconst typeToMatch =\r\n\t\tfilepath.split(\".\").pop()?.toLowerCase() !== \"php\"\r\n\t\t\t? \"call_expression\"\r\n\t\t\t: \"function_call_expression\";\r\n\r\n\tconst stringType = [\r\n\t\t\"name\",\r\n\t\t\"string\",\r\n\t\t\"string_value\",\r\n\t\t\"variable_name\",\r\n\t\t\"binary_expression\",\r\n\t\t\"member_expression\",\r\n\t\t\"subscript_expression\",\r\n\t\t\"shell_command_expression\",\r\n\t\t\"function_call_expression\",\r\n\t\t\"encapsed_string\",\r\n\t];\r\n\r\n\t/**\r\n\t * Traverse the tree \uD83C\uDF33\r\n\t *\r\n\t * @param {SyntaxNode} node The node to traverse through\r\n\t */\r\n\tfunction traverse(node: SyntaxNode): void {\r\n\t\t// Walk the tree\r\n\t\tif (node?.children.length)\r\n\t\t\tfor (const child of node.children) {\r\n\t\t\t\ttraverse(child);\r\n\t\t\t}\r\n\r\n\t\t// Check if the node matches\r\n\t\tif (node?.type === typeToMatch) {\r\n\t\t\t// The function name is the first child\r\n\t\t\tconst functionName = node.firstChild?.text ?? null;\r\n\t\t\tif (\r\n\t\t\t\tfunctionName === null ||\r\n\t\t\t\t!Object.keys(i18nFunctions).includes(functionName)\r\n\t\t\t) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// The arguments are the last child\r\n\t\t\tconst argsNode = node.lastChild;\r\n\t\t\tif (\r\n\t\t\t\targsNode === null ||\r\n\t\t\t\targsNode.childCount === 0 ||\r\n\t\t\t\targsNode.type !== \"arguments\"\r\n\t\t\t) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// Get the whole gettext translation string\r\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n\t\t\tconst [_fn, raw] = node.children;\r\n\t\t\tconst translation: Partial<{\r\n\t\t\t\tmsgctxt: string;\r\n\t\t\t\tmsgid: string;\r\n\t\t\t\tmsgid_plural: string;\r\n\t\t\t\tnumber: string;\r\n\t\t\t\tmsgstr: string;\r\n\t\t\t\ttext_domain: string;\r\n\t\t\t}> = {\r\n\t\t\t\t// WordPress default text domain is 'default'\r\n\t\t\t\ttext_domain: 'default',\r\n\t\t\t};\r\n\r\n\t\t\tconst translationKeys =\r\n\t\t\t\ti18nFunctions[functionName as keyof typeof i18nFunctions];\r\n\r\n\t\t\tconst children = raw.children.slice(1, -1);\r\n\t\t\tlet translationKeyIndex = 0;\r\n\r\n\t\t\t// Get the translation from the arguments (the quoted strings)\r\n\t\t\tfor (const child of children) {\r\n\t\t\t\tlet node = child;\r\n\t\t\t\tlet nodeValue: string | string[] = node.text;\r\n\r\n\t\t\t\t// unwrap the argument node, which is used in PHP.\r\n\t\t\t\tif (child.type === \"argument\") {\r\n\t\t\t\t\tif (child.children.length === 0) continue;\r\n\t\t\t\t\tnode = child.children[0];\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (node?.type === \",\") {\r\n\t\t\t\t\t// skip the comma between arguments\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the translation key (eg. msgid)\r\n\t\t\t\tconst currentKey = translationKeys[\r\n\t\t\t\t\ttranslationKeyIndex\r\n\t\t\t\t] as keyof typeof translation;\r\n\r\n\t\t\t\tif (node?.type && stringType.includes(node.type)) {\r\n\t\t\t\t\t// unquote the strings\r\n\t\t\t\t\tnodeValue = nodeValue.slice(1, -1);\r\n\t\t\t\t} else if (currentKey === 'number'){\r\n\t\t\t\t\t// `number` accepts any value, this will not be provided in the POT file\r\n\t\t\t\t\tnodeValue = node.text;\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// Whenever we get an unexpected node type this string is not translatable and should be skipped\r\n\t\t\t\t\tconsole.error(\r\n\t\t\t\t\t\t`Unexpected node type ${node?.type} identified as ${translationKeys[translationKeyIndex]} with value ${nodeValue} in ${filepath} at ${node.startPosition.row + 1} pos ${node.startPosition.column + 1}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn;  // Parse error, skip this translation.\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// the value of that key\r\n\t\t\t\ttranslation[currentKey] = nodeValue;\r\n\r\n\t\t\t\t// increment the index of the translation key\r\n\t\t\t\ttranslationKeyIndex += 1;\r\n\t\t\t}\r\n\r\n\t\t\tif (Array.isArray(args?.options?.translationDomains) && !args.options.translationDomains.includes(translation.text_domain as string)) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tconst comments = collectComments(argsNode);\r\n\r\n\t\t\t// Get the translation data\r\n\t\t\tconst block = new Block({\r\n\t\t\t\tmsgctxt: translation.msgctxt,\r\n\t\t\t\tmsgid: translation.msgid ?? \"\",\r\n\t\t\t\tmsgid_plural: translation.msgid_plural,\r\n\t\t\t\tmsgstr: translation.msgid_plural ? [\"\", \"\"] : [\"\"],\r\n\t\t\t\tcomments: {\r\n\t\t\t\t\ttranslator: comments ? [comments] : undefined,\r\n\t\t\t\t\treference: [\r\n\t\t\t\t\t\t`${reverseSlashes(filepath)}:${node.startPosition.row + 1}`,\r\n\t\t\t\t\t],\r\n\t\t\t\t},\r\n\t\t\t} as Block);\r\n\r\n\t\t\tgettextTranslations.add(block);\r\n\t\t}\r\n\t}\r\n\r\n\ttry {\r\n\t\tif (sourceCode) {\r\n\t\t\tconst fileSize = Buffer.byteLength(sourceCode, \"utf8\");\r\n\t\t\tlet bufferSize = 1024 * 32; // 32 KB default buffer size\r\n\r\n\t\t\tif (fileSize >= bufferSize) {\r\n\t\t\t\tbufferSize = fileSize + 32; // dynamic buffer size with 32 bytes of padding\r\n\t\t\t}\r\n\r\n\t\t\tif (fileSize >= 1024 * 1024 * 2) {\r\n\t\t\t\tconsole.warn(`File size warning: ${filepath} exceeds 2 MB.`);\r\n\t\t\t}\r\n\r\n\t\t\t// parse the file\r\n\t\t\tconst tree = parser.parse(sourceCode, undefined, { bufferSize });\r\n\t\t\tif (tree) {\r\n\t\t\t\ttraverse(tree.rootNode);\r\n\t\t\t}\r\n\t\t}\r\n\t} catch (e) {\r\n\t\tconsole.error(`Failed to parse ${filepath}: ${e}`);\r\n\t}\r\n\r\n\t// Return both matches and entries\r\n\treturn gettextTranslations;\r\n}\r\n"],
  "mappings": "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",
  "names": ["Parser", "node"]
}

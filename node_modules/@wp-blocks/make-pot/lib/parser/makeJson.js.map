{
  "version": 3,
  "sources": ["../../src/parser/makeJson.ts"],
  "sourcesContent": ["import crypto from \"node:crypto\";\r\nimport * as fs from \"node:fs\";\r\nimport path from \"node:path\";\r\nimport { transformSync } from \"@babel/core\";\r\nimport type { SetOfBlocks } from \"gettext-merger\";\r\nimport {\r\n\ttype GetTextTranslation,\r\n\ttype GetTextTranslations,\r\n\tpo,\r\n} from \"gettext-parser\";\r\nimport { glob } from \"glob\";\r\nimport { IsoCodeRegex, allowedFunctions, modulePath } from \"../const.js\";\r\nimport type { JedData, MakeJson, MakeJsonArgs } from \"../types.js\";\r\nimport { getPkgJsonData } from \"../utils/common.js\";\r\nimport { doTree } from \"./tree\";\r\n\r\nexport class MakeJsonCommand {\r\n\t/**\r\n\t * The source file path.\r\n\t * Should be the \"build\" directory containing .js files\r\n\t * @private\r\n\t */\r\n\tprivate readonly source: string;\r\n\t/**\r\n\t * The destination file path.\r\n\t * Should be the \"languages\" directory containing .po files\r\n\t * @private\r\n\t */\r\n\tprivate readonly destination: string;\r\n\t/**\r\n\t * The allowed file extensions.\r\n\t * @private\r\n\t */\r\n\tprivate readonly allowedFormats: string[];\r\n\t/**\r\n\t * Remove old POT files.\r\n\t * @private\r\n\t */\r\n\tprivate readonly purge: boolean;\r\n\t/**\r\n\t * Pretty print JSON.\r\n\t * @private\r\n\t */\r\n\tprivate readonly prettyPrint: boolean;\r\n\t/**\r\n\t * Enable debug mode.\r\n\t * @private\r\n\t */\r\n\tprivate debug: boolean;\r\n\t/**\r\n\t * The script to be translated.\r\n\t * @private\r\n\t */\r\n\tprivate scriptName: string | string[] | undefined;\r\n\t/**\r\n\t * The paths to be translated.\r\n\t * @private\r\n\t */\r\n\tprivate paths: object | undefined;\r\n\t/**\r\n\t * The source directory.\r\n\t * @private\r\n\t */\r\n\tprivate readonly sourceDir: string;\r\n\t/**\r\n\t * Whenever to strip unused translations from js files\r\n\t * @private\r\n\t */\r\n\tprivate stripUnused: boolean;\r\n\r\n\t/**\r\n\t * The constructor.\r\n\t * @param args - The arguments to the command.\r\n\t */\r\n\tpublic constructor(args: MakeJsonArgs) {\r\n\t\tthis.sourceDir = path.relative(args.paths.cwd, args.source ?? \"\");\r\n\t\tif (!fs.existsSync(this.sourceDir)) {\r\n\t\t\tconsole.error(\"Source directory not found\", args);\r\n\t\t\tthrow new Error(`Source directory ${this.sourceDir} not found`);\r\n\t\t}\r\n\r\n\t\tthis.stripUnused = args.stripUnused;\r\n\t\tthis.scriptName = args.scriptName;\r\n\t\tthis.source = args.source;\r\n\t\tthis.destination = args.destination;\r\n\t\tthis.allowedFormats = args.allowedFormats ?? [\r\n\t\t\t\".ts\",\r\n\t\t\t\".tsx\",\r\n\t\t\t\".js\",\r\n\t\t\t\".jsx\",\r\n\t\t\t\".mjs\",\r\n\t\t\t\".cjs\",\r\n\t\t];\r\n\t\tthis.purge = args.purge;\r\n\t\tthis.prettyPrint = args.prettyPrint;\r\n\t\tthis.debug = args.debug;\r\n\t\tthis.paths = args.paths;\r\n\t}\r\n\r\n\t/**\r\n\t * The main function. Parses the PO files and generates the JSON files.\r\n\t */\r\n\tpublic async exec(): Promise<Record<string, MakeJson>> {\r\n\t\t// get all the files in the source directory\r\n\t\tconst files = await glob(\"**/*.po\", { cwd: this.destination, nodir: true });\r\n\r\n\t\tconsole.log(\"Found po files\", files, \"in\", this.destination, \"folder\");\r\n\r\n\t\t// get all the po files\r\n\t\tconst output: Record<string, MakeJson> = {};\r\n\t\tfor (const file of files) {\r\n\t\t\tif (!this.scriptName) {\r\n\t\t\t\tthis.scriptName = await glob(\"**/*.js\", {\r\n\t\t\t\t\tcwd: this.source,\r\n\t\t\t\t\tnodir: true,\r\n\t\t\t\t});\r\n\t\t\t\tconsole.log(\r\n\t\t\t\t\t`Found script: ${this.scriptName} in ${this.source} folder`,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tif (typeof this.scriptName === \"string\") {\r\n\t\t\t\tthis.scriptName = [this.scriptName];\r\n\t\t\t}\r\n\r\n\t\t\tfor (const script of this.scriptName) {\r\n\t\t\t\tconst pot = this.addPot(file, script);\r\n\t\t\t\tif (pot.data) {\r\n\t\t\t\t\toutput[pot.filename] = pot.data;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tconsole.log(\r\n\t\t\t\t\t\t`\u274C Translation strings not found in Script ${script} in ${file} po file`,\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// write the json files\r\n\t\tfor (const [filename, content] of Object.entries(output)) {\r\n\t\t\tlet contentString: string;\r\n\t\t\tif (this.purge) {\r\n\t\t\t\tif (fs.existsSync(path.join(this.destination, filename))) {\r\n\t\t\t\t\tconsole.log(\r\n\t\t\t\t\t\t`Removing ${path.join(this.destination, filename)} as the purge option is enabled`,\r\n\t\t\t\t\t);\r\n\t\t\t\t\tfs.unlinkSync(path.join(this.destination, filename));\r\n\t\t\t\t}\r\n\t\t\t\tcontentString = JSON.stringify(\r\n\t\t\t\t\tcontent,\r\n\t\t\t\t\tnull,\r\n\t\t\t\t\tthis?.prettyPrint ? 2 : 0,\r\n\t\t\t\t);\r\n\t\t\t} else {\r\n\t\t\t\tconst oldJedContent = fs.readFileSync(\r\n\t\t\t\t\tpath.join(this.source, filename),\r\n\t\t\t\t\t\"utf8\",\r\n\t\t\t\t);\r\n\r\n\t\t\t\tcontentString = JSON.stringify(\r\n\t\t\t\t\t{ ...content, ...JSON.parse(oldJedContent) },\r\n\t\t\t\t\tnull,\r\n\t\t\t\t\tthis?.prettyPrint ? 2 : 0,\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\tconst destinationPath = path.join(this.destination, filename);\r\n\t\t\tfs.writeFileSync(destinationPath, contentString);\r\n\t\t\tconsole.log(\r\n\t\t\t\t`\u2705 JSON file written to ${destinationPath} with ${filename}`,\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// return the output\r\n\t\treturn output;\r\n\t}\r\n\r\n\t/**\r\n\t * Process a PO file and return the JSON data.\r\n\t * @param file - The path to the PO file.\r\n\t * @param script - The script to be translated.\r\n\t * @param encoding - The encoding of the PO file.\r\n\t */\r\n\tpublic processFile(\r\n\t\tfile: string,\r\n\t\tscript: string,\r\n\t\tencoding: BufferEncoding = \"utf8\",\r\n\t): MakeJson | null {\r\n\t\t// Get the file path\r\n\t\tconst filePath = path.join(this.destination, file);\r\n\r\n\t\t// Read the source file\r\n\t\tconst content = fs.readFileSync(filePath, encoding) as string;\r\n\r\n\t\t// Parse the source file\r\n\t\tconst poContent = this.parsePoFile(content);\r\n\r\n\t\tif (this.stripUnused) {\r\n\t\t\t// get the strings used in the script\r\n\t\t\tconst scriptContent = this.parseScript(script);\r\n\r\n\t\t\tif (!scriptContent) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// compare the strings used in the script with the strings in the po file\r\n\t\t\tconst stringsNotInPoFile = this.compareStrings(\r\n\t\t\t\tscriptContent.blocks,\r\n\t\t\t\tpoContent,\r\n\t\t\t);\r\n\r\n\t\t\tif (!stringsNotInPoFile) {\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// replace the po file strings with the strings used in the script\r\n\t\t\tpoContent.translations = stringsNotInPoFile.translations;\r\n\t\t}\r\n\r\n\t\t// Convert to Jed json dataset\r\n\t\treturn this.convertToJed(\r\n\t\t\tpoContent.headers,\r\n\t\t\tpoContent.translations,\r\n\t\t\tscript,\r\n\t\t\tthis.extractIsoCode(filePath), // extract the ISO code from the po filename\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes a PO file and returns the header and translations.\r\n\t * @param content - The content of the PO file.\r\n\t * @private\r\n\t *\r\n\t * @returns An object containing the header and translations.\r\n\t */\r\n\tprivate parsePoFile(content: string): GetTextTranslations {\r\n\t\treturn po.parse(content);\r\n\t}\r\n\r\n\t/**\r\n\t * Converts PO data to Jed data.\r\n\t * @param header - The header of the PO file.\r\n\t * @param translations - The translations of the PO file.\r\n\t * @param source - The source of the PO file.\r\n\t * @param languageIsoCode - The ISO code of the language.\r\n\t * @private\r\n\t *\r\n\t * @return An object containing the Jed data.\r\n\t */\r\n\tprivate convertToJed(\r\n\t\theader: Record<string, string>,\r\n\t\ttranslations: {\r\n\t\t\t[msgctxt: string]: { [msgId: string]: GetTextTranslation };\r\n\t\t},\r\n\t\tsource: string,\r\n\t\tlanguageIsoCode?: string,\r\n\t): MakeJson {\r\n\t\tconst packageJson = getPkgJsonData(modulePath, \"name\", \"version\") as {\r\n\t\t\tname: string;\r\n\t\t\tversion: string;\r\n\t\t};\r\n\r\n\t\t// Domain name to use for the Jed format\r\n\t\tconst domain: string = \"messages\";\r\n\r\n\t\tconst generator = `${packageJson.name}/${packageJson.version}`;\r\n\r\n\t\t// Initialize the Jed-compatible structure\r\n\t\tconst jedData: JedData = {\r\n\t\t\t[domain]: {\r\n\t\t\t\t\"\": {\r\n\t\t\t\t\tdomain,\r\n\t\t\t\t\tlang: languageIsoCode || header.Language || \"en\",\r\n\t\t\t\t\tplural_forms:\r\n\t\t\t\t\t\theader[\"Plural-Forms\"] || \"nplurals=2; plural=(n != 1);\",\r\n\t\t\t\t},\r\n\t\t\t},\r\n\t\t};\r\n\r\n\t\t// Process all translations\r\n\t\tfor (const msgctxt of Object.keys(translations)) {\r\n\t\t\tconst contextTranslations = translations[msgctxt];\r\n\r\n\t\t\tfor (const msgid of Object.keys(contextTranslations)) {\r\n\t\t\t\tconst translation = contextTranslations[msgid];\r\n\r\n\t\t\t\t// Skip empty msgid (header) as we've already handled it\r\n\t\t\t\tif (msgid === \"\") continue;\r\n\r\n\t\t\t\t// Construct the key using context if available\r\n\t\t\t\tconst key =\r\n\t\t\t\t\tmsgctxt && msgctxt !== \"\" ? `${msgctxt}\\u0004${msgid}` : msgid;\r\n\r\n\t\t\t\t// Add the translation to the Jed data structure\r\n\t\t\t\tjedData[domain][key] = translation.msgstr;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst makeJson: {\r\n\t\t\tdomain: string;\r\n\t\t\tgenerator: string;\r\n\t\t\t\"translation-revision-date\": string;\r\n\t\t\tsource: string;\r\n\t\t\tlocale_data: JedData;\r\n\t\t} = {\r\n\t\t\t\"translation-revision-date\": new Date().toISOString(),\r\n\t\t\tgenerator: generator,\r\n\t\t\tsource: path.join(this.sourceDir, source).replace(/\\\\/g, \"/\"),\r\n\t\t\tdomain,\r\n\t\t\tlocale_data: jedData,\r\n\t\t};\r\n\r\n\t\treturn makeJson as MakeJson;\r\n\t}\r\n\r\n\t/**\r\n\t * Gets the ISO code from the filename.\r\n\t * @param filename The filename to extract the ISO code from.\r\n\t * @private\r\n\t *\r\n\t * @returns The ISO code if found, otherwise null.\r\n\t */\r\n\tprivate extractIsoCode(filename: string): string | undefined {\r\n\t\tconst match = filename.match(IsoCodeRegex);\r\n\t\treturn match ? match[1] : undefined;\r\n\t}\r\n\r\n\t/**\r\n\t * Takes a string and returns its md5 hash.\r\n\t * @param text\r\n\t * @private\r\n\t */\r\n\tprivate md5(text: string): string {\r\n\t\treturn crypto.createHash(\"md5\").update(text).digest(\"hex\");\r\n\t}\r\n\r\n\t/**\r\n\t * Generates the filename for the json file.\r\n\t * @param script\r\n\t * @param file\r\n\t * @private\r\n\t */\r\n\tprivate generateFilename(script: string, file: string): string {\r\n\t\tconst scriptName = this.md5(script);\r\n\t\t//build the filename for the json file using the po files\r\n\t\treturn file.replace(\".po\", `-${scriptName}.json`);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a script to the output object.\r\n\t * @private\r\n\t *\r\n\t * @param potFile - The pot file to parse.\r\n\t * @param script - The script to add.\r\n\t * @return {Record<string, JedData>} - The output object.\r\n\t * */\r\n\tprivate addPot(\r\n\t\tpotFile: string,\r\n\t\tscript: string,\r\n\t): { filename: string; data: MakeJson | null } {\r\n\t\tconst filename = this.generateFilename(\r\n\t\t\tpath.join(this.source, script).replace(/\\\\/g, \"/\"),\r\n\t\t\tpotFile,\r\n\t\t);\r\n\t\t// the processed file is added to the output object\r\n\t\treturn {\r\n\t\t\tfilename,\r\n\t\t\tdata: this.processFile(potFile, script),\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Compares the strings used in the script with the strings in the po file.\r\n\t * @param jsArray - The strings used in the script.\r\n\t * @param poObject - The content of the po file.\r\n\t * @private\r\n\t */\r\n\tprivate compareStrings(\r\n\t\tjsArray: SetOfBlocks[\"blocks\"],\r\n\t\tpoObject: GetTextTranslations,\r\n\t): GetTextTranslations | null {\r\n\t\t// The copy of the po file with only the strings used in the script\r\n\t\tconst filteredPo = {\r\n\t\t\tcharset: poObject.charset,\r\n\t\t\theaders: { ...poObject.headers },\r\n\t\t\ttranslations: { \"\": {} },\r\n\t\t} as GetTextTranslations;\r\n\r\n\t\t// copy the original header\r\n\t\tif (poObject.translations[\"\"][\"\"]) {\r\n\t\t\tfilteredPo.translations[\"\"][\"\"] = { ...poObject.translations[\"\"][\"\"] };\r\n\t\t}\r\n\r\n\t\t// Create a set of message ids from the JS file\r\n\t\tconst jsMessageIds = new Set(jsArray.map((item) => item.msgid));\r\n\r\n\t\t// Iterate over the po file and keep only the strings used in the script\r\n\t\tfor (const domain in poObject.translations) {\r\n\t\t\tif (domain !== \"\") continue; // handle only the main domain\r\n\r\n\t\t\tfor (const msgid in poObject.translations[domain]) {\r\n\t\t\t\tif (msgid === \"\") continue; // Skip the header\r\n\r\n\t\t\t\tif (jsMessageIds.has(msgid)) {\r\n\t\t\t\t\t// ok the msgid is used\r\n\t\t\t\t\tif (!filteredPo.translations[domain]) {\r\n\t\t\t\t\t\tfilteredPo.translations[domain] = {};\r\n\t\t\t\t\t}\r\n\t\t\t\t\tfilteredPo.translations[domain][msgid] = {\r\n\t\t\t\t\t\t...poObject.translations[domain][msgid],\r\n\t\t\t\t\t};\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// check if the po file is empty, 1 means that the header is the only string available\r\n\t\t// TODO: if the json file is empty, we should delete it?\r\n\t\tif (Object.keys(filteredPo.translations[\"\"]).length <= 1) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\treturn filteredPo;\r\n\t}\r\n\r\n\tprivate parseScript(script: string): SetOfBlocks | undefined {\r\n\t\tconst fileContent = fs.readFileSync(path.join(this.source, script), \"utf8\");\r\n\t\tconst transformedScript = transformSync(fileContent, {\r\n\t\t\tconfigFile: false,\r\n\t\t\tpresets: [\"@babel/preset-env\"],\r\n\t\t\tcompact: false,\r\n\t\t\tcomments: true,\r\n\t\t\tsourceMaps: false,\r\n\t\t\tplugins: [\r\n\t\t\t\t({ types: t }) => ({\r\n\t\t\t\t\tvisitor: {\r\n\t\t\t\t\t\tCallExpression(path) {\r\n\t\t\t\t\t\t\tconst callee = path.node.callee;\r\n\r\n\t\t\t\t\t\t\t// Check for pattern like: (fn)(\"...\")\r\n\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\tt.isSequenceExpression(callee) &&\r\n\t\t\t\t\t\t\t\tt.isMemberExpression(callee.expressions[1])\r\n\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\tconst property = callee.expressions[1].property;\r\n\r\n\t\t\t\t\t\t\t\tif (\r\n\t\t\t\t\t\t\t\t\tt.isIdentifier(property) &&\r\n\t\t\t\t\t\t\t\t\tallowedFunctions.has(property.name)\r\n\t\t\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t\t\t// Replace with direct function call: __(\"...\"), _n(...), etc.\r\n\t\t\t\t\t\t\t\t\tpath.node.callee = t.identifier(property.name);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t},\r\n\t\t\t\t}),\r\n\t\t\t],\r\n\t\t}).code as string;\r\n\r\n\t\treturn doTree(transformedScript, script, this.debug);\r\n\t}\r\n}\r\n\r\nexport default MakeJsonCommand;\r\n"],
  "mappings": "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",
  "names": ["path", "crypto"]
}

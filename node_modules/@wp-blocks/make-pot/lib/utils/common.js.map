{
  "version": 3,
  "sources": ["../../src/utils/common.ts"],
  "sourcesContent": ["import fs from \"node:fs\";\r\nimport { cpus, totalmem } from \"node:os\";\r\nimport path from \"node:path\";\r\nimport { modulePath } from \"../const.js\";\r\nimport type { Patterns } from \"../types.js\";\r\n\r\n/**\r\n * A function that removes comment markup from a given string.\r\n *\r\n * @param {string} input - The input string with comment markup.\r\n * @return {string} - The input string without comment markup.\r\n */\r\nexport function getCommentBlock(input: string): string {\r\n\tconst commentBlock = input.match(/\\/\\*\\*?[\\s\\S]*?\\*\\//);\r\n\treturn commentBlock !== null ? commentBlock[0] : input;\r\n}\r\n\r\n/**\r\n * A function that starts to capture the text after the first letter.\r\n *\r\n * @param {string} input - The input string with comment markup.\r\n * @return {string} - The input string without comment markup.\r\n */\r\nexport function removeCommentMarkup(input: string): string[] | null {\r\n\treturn input.match(/[a-zA-Z].*/gm);\r\n}\r\n\r\n/**\r\n * Removes the markup from a comment string.\r\n *\r\n * @param {string} comment - The comment string to remove markup from.\r\n * @return {string} The comment text without the markers.\r\n */\r\nexport function stripTranslationMarkup(comment: string): string {\r\n\tconst commentPattern =\r\n\t\t/\\/\\*\\*?\\s*(?:translators:)\\s*([\\s\\S]*?)\\s*\\*\\/|\\/\\/\\s*(?:translators:)\\s*(.*)$/i;\r\n\tconst matches = comment.match(commentPattern);\r\n\treturn matches ? matches[1] : comment;\r\n}\r\n\r\n/**\r\n * Splits a string into an array of strings based on the presence of a comma.\r\n *\r\n * @param {string} string - The string to be split.\r\n * @return {string[]} An array of strings after splitting the input string.\r\n */\r\nexport function stringstring(string: string | string[] | undefined): string[] {\r\n\tif (typeof string === \"string\") {\r\n\t\tif (string.includes(\",\")) {\r\n\t\t\treturn string.split(\",\");\r\n\t\t}\r\n\t\treturn [string];\r\n\t}\r\n\treturn [];\r\n}\r\n\r\n/**\r\n * Determines if a pattern represents a file, a directory, or a glob pattern.\r\n * @param pattern - The pattern string to evaluate.\r\n * @returns 'file', 'directory', or 'glob'.\r\n */\r\nexport function detectPatternType(\r\n\tpattern: string,\r\n): \"file\" | \"directory\" | \"glob\" {\r\n\tconst containsFileExtension = pattern.includes(\".\");\r\n\tconst containsDirectorySeparator = pattern.includes(path.sep);\r\n\r\n\tif (pattern.includes(\"*\")) {\r\n\t\treturn \"glob\";\r\n\t}\r\n\tif (!containsFileExtension && !containsDirectorySeparator) {\r\n\t\treturn \"directory\";\r\n\t}\r\n\tif (containsFileExtension && !containsDirectorySeparator) {\r\n\t\treturn \"file\";\r\n\t}\r\n\treturn \"glob\";\r\n}\r\n\r\n/**\r\n * Gets the file extension from a filename.\r\n * @param filename - The name of the file to extract the extension from.\r\n * @returns The file extension, or 'blade.php' for Blade templates.\r\n */\r\nexport function getFileExtension(filename: string): string {\r\n\tif (filename.endsWith(\".blade.php\")) {\r\n\t\treturn \"blade.php\";\r\n\t}\r\n\treturn filename.split(\".\").pop() || \"\";\r\n}\r\n\r\n/**\r\n * Generates a copyright comment for the specified slug and license.\r\n *\r\n * @param slug - The slug to include in the copyright comment\r\n * @param [license='GPL v2 or later'] - The license to use in the copyright comment\r\n * @return The generated copyright comment\r\n */\r\nexport function getCopyright(\r\n\tslug: string,\r\n\tlicense = \"GPL v2 or later\",\r\n): string {\r\n\treturn (\r\n\t\t`# Copyright (C) ${new Date().getFullYear()} ${slug}\\n` +\r\n\t\t`# This file is distributed under the ${license} license.`\r\n\t);\r\n}\r\n\r\n/**\r\n * Reverse slashes in a path, and replace backward slashes with forward slashes\r\n *\r\n * @param filePath - The path to be reversed.\r\n * @return {string} The reversed path.\r\n */\r\nexport function reverseSlashes(filePath: string): string {\r\n\t// Replace backward slashes with forward slashes\r\n\treturn filePath.replace(/\\\\/g, \"/\");\r\n}\r\n\r\n/**\r\n *  The makepot package.json file data\r\n *  @arguments {string[]} fields - The fields to extract\r\n *  @return {Record<string, unknown>} - The package.json data\r\n */\r\nexport function getPkgJsonData(\r\n\tlocation?: string,\r\n\t...fields: string[]\r\n): Record<string, unknown> {\r\n\tconst requested: Record<string, unknown> = {};\r\n\t// read the package.json file the is in the root directory\r\n\tconst pkgJsonPath = path.join(location || process.cwd(), \"package.json\");\r\n\t// read the package.json file or return an empty object\r\n\tconst pkgJson: Record<string, unknown> = fs.existsSync(pkgJsonPath)\r\n\t\t? require(pkgJsonPath)\r\n\t\t: {};\r\n\t// extract the requested fields from the package.json\r\n\tfor (const field of fields) {\r\n\t\tif (pkgJson[field]) {\r\n\t\t\trequested[field] = pkgJson[field];\r\n\t\t}\r\n\t}\r\n\treturn requested;\r\n}\r\n\r\n/**\r\n * Print the module header with the current version and name\r\n */\r\nexport function printModuleInfo() {\r\n\tconst { version, name } = getPkgJsonData(modulePath, \"name\", \"version\");\r\n\t/* print the version */\r\n\tconsole.log(`${name} version: ${version}`);\r\n}\r\n\r\n/**\r\n * Output to the console the time elapsed in milliseconds between two dates\r\n * @param scriptName the name of the script\r\n * @param timeStart the start time\r\n * @param timeEnd the end time\r\n */\r\nexport function printTimeElapsed(\r\n\tscriptName: \"Make-Pot\" | \"Make-Json\",\r\n\ttimeStart: Date,\r\n\ttimeEnd: Date = new Date(),\r\n) {\r\n\tconsole.log(\r\n\t\t`\\n\uD83D\uDE80 ${scriptName}: Task completed! ${scriptName.split(\"-\")[1]} file created in ${\r\n\t\t\ttimeEnd.getTime() - timeStart.getTime()\r\n\t\t}ms`,\r\n\t);\r\n}\r\n\r\n/**\r\n/**\r\n* Prints the memory usage and cpu usage of the system\r\n */\r\nexport function printStats() {\r\n\tconsole.log(\r\n\t\t\"Memory usage:\",\r\n\t\t(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2),\r\n\t\t\"MB (Free:\",\r\n\t\t(totalmem() / 1024 / 1024 / 1024).toFixed(2),\r\n\t\t\"GB)\\nCpu User:\",\r\n\t\t(process.cpuUsage().user / 1000000).toFixed(2),\r\n\t\t\"ms Cpu System:\",\r\n\t\t(process.cpuUsage().system / 1000000).toFixed(2),\r\n\t\t\"ms of\",\r\n\t\tcpus().length,\r\n\t\t\"cores\",\r\n\t);\r\n}\r\n\r\n/**\r\n * Returns the output path recap\r\n *\r\n * @param {string} cwd - The current working directory\r\n * @param {Patterns} patterns - The patterns to be used for the extraction process\r\n * @return {string} - The output path recap\r\n */\r\nexport function outputPathRecap(cwd: string, patterns: Patterns): string {\r\n\treturn `\\nScript Path: ${cwd}\\nfor ${patterns.include.join()}\\nignoring patterns: ${patterns.exclude.join()}\\n`;\r\n}\r\n"],
  "mappings": "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",
  "names": ["path", "fs"]
}

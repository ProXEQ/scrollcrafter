{
  "version": 3,
  "sources": ["../../src/extractors/json.ts"],
  "sourcesContent": ["import path from \"node:path\";\nimport type { Block, SetOfBlocks } from \"gettext-merger\";\nimport type { I18nSchema } from \"../types.js\";\nimport { yieldParsedData } from \"../utils/extractors.js\";\nimport { JsonSchemaExtractor } from \"./schema.js\";\n\n/**\n * Parses a JSON file and returns an array of parsed data.\n *\n * @param {Object} opts - The arguments for parsing the JSON file.\n * @param {string} opts.filepath - The filepath of the JSON file to parse.\n * @param {Object} [opts.stats] - Optional statistics object.\n * @param {number} opts.stats.index - The index of the progress bar.\n * @return {Promise<TranslationStrings>} A promise that resolves to an object containing the parsed data.\n */\nexport async function parseJsonFile(opts: {\n\tfileContent: string;\n\tfilename: \"block.json\" | \"theme.json\";\n}): Promise<Block[]> {\n\tconst isTheme = opts.filename === \"theme.json\";\n\tconst schema: { url: string; fallback: I18nSchema } = {\n\t\turl: isTheme\n\t\t\t? JsonSchemaExtractor.themeJsonSource\n\t\t\t: JsonSchemaExtractor.blockJsonSource,\n\t\tfallback: isTheme\n\t\t\t? (JsonSchemaExtractor.themeJsonFallback as I18nSchema)\n\t\t\t: (JsonSchemaExtractor.blockJsonFallback as I18nSchema),\n\t};\n\n\tif (!schema.url || !schema.fallback) {\n\t\tconsole.error(\"Schema URL or fallback not provided\");\n\t\treturn;\n\t}\n\n\t// Get the JSON translations from the schema\n\tconst jsonTranslations = await JsonSchemaExtractor.parse(\n\t\topts.fileContent,\n\t\tschema,\n\t\t{\n\t\t\tfile: opts.filename,\n\t\t\taddReferences: true,\n\t\t},\n\t);\n\n\treturn jsonTranslations ?? [];\n}\n\n/**\n * Parses the JSON content of a file based on the filename and file content.\n *\n * @param {string} fileContent - The content of the file to parse.\n * @param {string} filePath - The path of the file being parsed.\n * @param {'block.json' | 'theme.json'} filename - The type of JSON file being parsed.\n * @return {Promise<TranslationStrings>} The parsed translation strings.\n */\nexport async function parseJsonCallback(\n\tfileContent: string,\n\tfilePath: string,\n\tfilename: \"block.json\" | \"theme.json\",\n): Promise<SetOfBlocks> {\n\tconst data = await parseJsonFile({\n\t\tfileContent: fileContent,\n\t\tfilename: filename,\n\t});\n\n\treturn yieldParsedData(data, filename, path.join(filePath, filename));\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAAiB;AAGjB,wBAAgC;AAChC,oBAAoC;AAWpC,eAAsB,cAAc,MAGf;AACpB,QAAM,UAAU,KAAK,aAAa;AAClC,QAAM,SAAgD;AAAA,IACrD,KAAK,UACF,kCAAoB,kBACpB,kCAAoB;AAAA,IACvB,UAAU,UACN,kCAAoB,oBACpB,kCAAoB;AAAA,EACzB;AAEA,MAAI,CAAC,OAAO,OAAO,CAAC,OAAO,UAAU;AACpC,YAAQ,MAAM,qCAAqC;AACnD;AAAA,EACD;AAGA,QAAM,mBAAmB,MAAM,kCAAoB;AAAA,IAClD,KAAK;AAAA,IACL;AAAA,IACA;AAAA,MACC,MAAM,KAAK;AAAA,MACX,eAAe;AAAA,IAChB;AAAA,EACD;AAEA,SAAO,oBAAoB,CAAC;AAC7B;AAUA,eAAsB,kBACrB,aACA,UACA,UACuB;AACvB,QAAM,OAAO,MAAM,cAAc;AAAA,IAChC;AAAA,IACA;AAAA,EACD,CAAC;AAED,aAAO,mCAAgB,MAAM,UAAU,iBAAAA,QAAK,KAAK,UAAU,QAAQ,CAAC;AACrE;",
  "names": ["path"]
}

{
  "version": 3,
  "sources": ["../../src/extractors/schema.ts"],
  "sourcesContent": ["import type { Block } from \"gettext-merger\";\r\nimport type BlockI18n from \"../assets/block-i18n.js\";\r\nimport * as blocki18n from \"../assets/block-i18n.js\";\r\nimport type ThemeI18n from \"../assets/theme-i18n.js\";\r\nimport * as themei18n from \"../assets/theme-i18n.js\";\r\nimport type { I18nSchema } from \"../types.js\";\r\n\r\n/**\r\n * Extracts strings from JSON files using the I18n schema.\r\n */\r\nexport class JsonSchemaExtractor {\r\n\tprivate static schemaCache: { [url: string]: I18nSchema } = {};\r\n\r\n\t/** Theme */\r\n\tstatic themeJsonSource =\r\n\t\t\"http://develop.svn.wordpress.org/trunk/src/wp-includes/theme-i18n.json\";\r\n\tstatic themeJsonFallback = themei18n as ThemeI18n;\r\n\t/** Block */\r\n\tstatic blockJsonSource =\r\n\t\t\"http://develop.svn.wordpress.org/trunk/src/wp-includes/block-i18n.json\";\r\n\tstatic blockJsonFallback = blocki18n as BlockI18n;\r\n\r\n\t/**\r\n\t * Load the schema from the specified URL, with a fallback URL if needed.\r\n\t *\r\n\t * @param {string} url - The URL to load the schema from.\r\n\t * @param {I18nSchema} fallback - The fallback schema to use if the main URL fails.\r\n\t * @return {Promise<I18nSchema>} The loaded schema.\r\n\t */\r\n\tprivate static async loadSchema(\r\n\t\turl: string,\r\n\t\tfallback: I18nSchema,\r\n\t): Promise<I18nSchema> {\r\n\t\tif (JsonSchemaExtractor.schemaCache[url]) {\r\n\t\t\treturn JsonSchemaExtractor.schemaCache[url];\r\n\t\t}\r\n\r\n\t\ttry {\r\n\t\t\tconsole.log(`\\n[i] Loading schema from ${url}`);\r\n\t\t\tconst response = await fetch(url, {\r\n\t\t\t\tresponseType: \"json\",\r\n\t\t\t\taccept: \"application/json\",\r\n\t\t\t\theaders: {\r\n\t\t\t\t\t\"Access-Control-Allow-Origin\": \"*\",\r\n\t\t\t\t},\r\n\t\t\t})\r\n\t\t\t\t.then((response) => response.json())\r\n\t\t\t\t.catch((error: Error) => {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t`\\nFailed to load schema from ${url}. Error: ${error.message}`,\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\r\n\t\t\t// Verify if the response is valid\r\n\t\t\tif (!response) {\r\n\t\t\t\treturn fallback;\r\n\t\t\t}\r\n\r\n\t\t\tconsole.log(\"Schema loaded successfully\");\r\n\t\t\tJsonSchemaExtractor.schemaCache[url] = response;\r\n\t\t\treturn response;\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(\r\n\t\t\t\t`\\nFailed to load schema from ${url}. Using fallback. Error: ${error.message}`,\r\n\t\t\t);\r\n\t\t\tJsonSchemaExtractor.schemaCache[url] = fallback;\r\n\t\t\treturn fallback;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Parses a string and extracts translations using the specified schema.\r\n\t *\r\n\t * @param {string} text - the input string to be parsed\r\n\t * @param {object} schema - the schema to use for parsing the input string\r\n\t * @param {string} schema.url - the URL of the schema to use for parsing the input string\r\n\t * @param {object} schema.schemaFallback - the fallback schema to use if the main schema fails\r\n\t * @param {object} options - the options for parsing the input string\r\n\t * @param {string} options.file - the name of the file being parsed\r\n\t * @param {boolean} options.addReferences - whether to add references to the extracted strings\r\n\t *\r\n\t * @return {Promise<I18nSchema | undefined>} a promise that resolves with the extracted schema\r\n\t */\r\n\tpublic static async parse(\r\n\t\ttext: string,\r\n\t\tschema: {\r\n\t\t\turl: string;\r\n\t\t\tfallback: I18nSchema;\r\n\t\t},\r\n\t\toptions: {\r\n\t\t\tfile: \"block.json\" | \"theme.json\";\r\n\t\t\taddReferences: boolean;\r\n\t\t},\r\n\t): Promise<Block[] | undefined> {\r\n\t\tconst parsedSchema = await JsonSchemaExtractor.loadSchema(\r\n\t\t\tschema.url,\r\n\t\t\tschema.fallback,\r\n\t\t);\r\n\r\n\t\ttry {\r\n\t\t\tconst json = JSON.parse(text) as Record<string, unknown>;\r\n\t\t\tif (!json) {\r\n\t\t\t\tconsole.error(\"Could not parse JSON.\");\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\treturn JsonSchemaExtractor.extractFromJsonSchema(\r\n\t\t\t\tjson,\r\n\t\t\t\tparsedSchema,\r\n\t\t\t\toptions,\r\n\t\t\t);\r\n\t\t} catch (error) {\r\n\t\t\tconsole.error(`Error parsing JSON: ${error.message}`);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Extracts translatable strings from a JSON file by comparing it with a schema\r\n\t *\r\n\t * @param {Object} json - The JSON object to extract strings from\r\n\t * @param {Object} schema - The schema that defines which fields contain translatable strings\r\n\t * @param {Object} options - Options for extraction\r\n\t * @param {string} options.filename - The name of the file being extracted (for references)\r\n\t * @param {boolean} options.addReferences - Whether to add file references in comments\r\n\t * @return {Array} - An array of objects with translatable strings in gettext format\r\n\t */\r\n\tprivate static extractFromJsonSchema(\r\n\t\tjson: Record<string, unknown>,\r\n\t\tschema: I18nSchema,\r\n\t\toptions: { filename?: string; addReferences?: boolean } = {\r\n\t\t\tfilename: undefined,\r\n\t\t\taddReferences: false,\r\n\t\t},\r\n\t): Block[] | undefined {\r\n\t\tconst { filename = \"block.json\", addReferences = false } = options;\r\n\t\tconst translations = [];\r\n\r\n\t\t/**\r\n\t\t * Recursive function to extract translatable strings\r\n\t\t * @param {*} currentJson - The current node in the JSON\r\n\t\t * @param {*} currentSchema - The current node in the schema\r\n\t\t * @param {Array} path - The current path in the JSON\r\n\t\t */\r\n\t\tfunction extract(currentJson, currentSchema, path = []) {\r\n\t\t\t// If either is null or undefined, there's nothing to do\r\n\t\t\tif (!currentJson || !currentSchema) return;\r\n\r\n\t\t\t// Handles the case where both are objects\r\n\t\t\tif (\r\n\t\t\t\ttypeof currentJson === \"object\" &&\r\n\t\t\t\t!Array.isArray(currentJson) &&\r\n\t\t\t\ttypeof currentSchema === \"object\" &&\r\n\t\t\t\t!Array.isArray(currentSchema)\r\n\t\t\t) {\r\n\t\t\t\t// Iterate over the schema keys\r\n\t\t\t\tfor (const key of Object.keys(currentSchema)) {\r\n\t\t\t\t\tif (key in currentJson) {\r\n\t\t\t\t\t\t// If the key exists in the JSON, check the type\r\n\t\t\t\t\t\tif (typeof currentJson[key] === \"string\") {\r\n\t\t\t\t\t\t\t// It's a string - add it to translations\r\n\t\t\t\t\t\t\taddTranslation(\r\n\t\t\t\t\t\t\t\tcurrentJson[key],\r\n\t\t\t\t\t\t\t\tcurrentSchema[key],\r\n\t\t\t\t\t\t\t\tfilename,\r\n\t\t\t\t\t\t\t\taddReferences,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\tArray.isArray(currentJson[key]) &&\r\n\t\t\t\t\t\t\tArray.isArray(currentSchema[key])\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t// It's an array - handle each element\r\n\t\t\t\t\t\t\thandleArrays(\r\n\t\t\t\t\t\t\t\tcurrentJson[key],\r\n\t\t\t\t\t\t\t\tcurrentSchema[key],\r\n\t\t\t\t\t\t\t\t[...path, key],\r\n\t\t\t\t\t\t\t\tfilename,\r\n\t\t\t\t\t\t\t\taddReferences,\r\n\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t} else if (\r\n\t\t\t\t\t\t\ttypeof currentJson[key] === \"object\" &&\r\n\t\t\t\t\t\t\ttypeof currentSchema[key] === \"object\"\r\n\t\t\t\t\t\t) {\r\n\t\t\t\t\t\t\t// It's an object - recurse\r\n\t\t\t\t\t\t\textract(currentJson[key], currentSchema[key], [...path, key]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Handles arrays in JSON and schema\r\n\t\t * @param {Array} jsonArray - The JSON array\r\n\t\t * @param {Array} schemaArray - The schema array\r\n\t\t * @param {Array} path - The current path\r\n\t\t * @param {string} filename - The name of the file\r\n\t\t * @param {boolean} addReferences - whenever to add references\r\n\t\t */\r\n\t\tfunction handleArrays(\r\n\t\t\tjsonArray,\r\n\t\t\tschemaArray,\r\n\t\t\tpath,\r\n\t\t\tfilename,\r\n\t\t\taddReferences,\r\n\t\t) {\r\n\t\t\t// If the schema has at least one element, use it as a template\r\n\t\t\tif (schemaArray.length > 0) {\r\n\t\t\t\tconst schemaTemplate = schemaArray[0];\r\n\r\n\t\t\t\t// For each element in the JSON array\r\n\t\t\t\tfor (const jsonItem of jsonArray) {\r\n\t\t\t\t\tif (typeof jsonItem === \"string\") {\r\n\t\t\t\t\t\t// If the JSON element is a string, add it directly\r\n\t\t\t\t\t\taddTranslation(jsonItem, schemaTemplate, filename, addReferences);\r\n\t\t\t\t\t} else if (typeof jsonItem === \"object\") {\r\n\t\t\t\t\t\t// If it's an object, recurse\r\n\t\t\t\t\t\tif (typeof schemaTemplate === \"object\") {\r\n\t\t\t\t\t\t\textract(jsonItem, schemaTemplate, path);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t// Edge case: handles cases like keywords: [\"string1\", \"string2\"]\r\n\t\t\t\t\t\t\t// when the schema has keywords: [\"keyword context\"]\r\n\t\t\t\t\t\t\tfor (const key of Object.keys(jsonItem)) {\r\n\t\t\t\t\t\t\t\tif (typeof jsonItem[key] === \"string\") {\r\n\t\t\t\t\t\t\t\t\taddTranslation(\r\n\t\t\t\t\t\t\t\t\t\tjsonItem[key],\r\n\t\t\t\t\t\t\t\t\t\tschemaTemplate,\r\n\t\t\t\t\t\t\t\t\t\tfilename,\r\n\t\t\t\t\t\t\t\t\t\taddReferences,\r\n\t\t\t\t\t\t\t\t\t);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t/**\r\n\t\t * Adds a translation to the translations array\r\n\t\t * @param {string} msgctxt - The context of the text to be translated\r\n\t\t * @param {string} msgid - The text to be translated\r\n\t\t * @param {string} filename - The name of the file for references\r\n\t\t * @param {boolean} addReferences - Whether to add references\r\n\t\t */\r\n\t\tfunction addTranslation(msgctxt, msgid, filename, addReferences) {\r\n\t\t\tif (!msgctxt) return; // Do not add empty strings\r\n\r\n\t\t\tconst translation = {\r\n\t\t\t\tmsgid,\r\n\t\t\t\tmsgctxt,\r\n\t\t\t} as Block;\r\n\r\n\t\t\tif (addReferences) {\r\n\t\t\t\ttranslation.comments = {\r\n\t\t\t\t\treference: [filename],\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\ttranslations.push(translation);\r\n\t\t}\r\n\r\n\t\t// Start extraction from the root\r\n\t\textract(json, schema);\r\n\r\n\t\treturn translations;\r\n\t}\r\n}\r\n"],
  "mappings": "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",
  "names": ["response", "filename", "addReferences"]
}

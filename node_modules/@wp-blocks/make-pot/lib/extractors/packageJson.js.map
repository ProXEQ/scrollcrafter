{
  "version": 3,
  "sources": ["../../src/extractors/packageJson.ts"],
  "sourcesContent": ["import fs from \"node:fs\";\nimport path from \"node:path\";\nimport { pkgJsonHeaders } from \"../const.js\";\nimport type { Args } from \"../types.js\";\n\n/**\n * Extracts package data from the given arguments and returns a record\n * containing the specified fields from the package.json file.\n *\n * @param {Args} args - The arguments for extracting package data.\n *\n * @return {Record<string, string>} - A record containing the extracted package data.\n */\nexport function extractPackageJson(args: Args): Record<string, string> {\n\tconst fields = pkgJsonHeaders;\n\tconst pkgJsonMeta: Record<string, string> = {};\n\t// read the package.json file\n\tconst packageJsonPath = args.paths.cwd\n\t\t? path.join(args.paths.cwd, \"package.json\")\n\t\t: \"package.json\";\n\n\t/**\n\t *  check if the package.json extract the fields from the package.json file\n\t */\n\tif (fs.existsSync(packageJsonPath)) {\n\t\tconst packageJson = JSON.parse(fs.readFileSync(packageJsonPath, \"utf8\"));\n\t\tfor (const field of Object.keys(fields)) {\n\t\t\t// if the field exists in the package.json\n\t\t\tif (field in packageJson) {\n\t\t\t\tpkgJsonMeta[field] = `${packageJson[field]}` as string;\n\t\t\t}\n\t\t}\n\t}\n\treturn pkgJsonMeta;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAAe;AACf,uBAAiB;AACjB,mBAA+B;AAWxB,SAAS,mBAAmB,MAAoC;AACtE,QAAM,SAAS;AACf,QAAM,cAAsC,CAAC;AAE7C,QAAM,kBAAkB,KAAK,MAAM,MAChC,iBAAAA,QAAK,KAAK,KAAK,MAAM,KAAK,cAAc,IACxC;AAKH,MAAI,eAAAC,QAAG,WAAW,eAAe,GAAG;AACnC,UAAM,cAAc,KAAK,MAAM,eAAAA,QAAG,aAAa,iBAAiB,MAAM,CAAC;AACvE,eAAW,SAAS,OAAO,KAAK,MAAM,GAAG;AAExC,UAAI,SAAS,aAAa;AACzB,oBAAY,KAAK,IAAI,GAAG,YAAY,KAAK,CAAC;AAAA,MAC3C;AAAA,IACD;AAAA,EACD;AACA,SAAO;AACR;",
  "names": ["path", "fs"]
}

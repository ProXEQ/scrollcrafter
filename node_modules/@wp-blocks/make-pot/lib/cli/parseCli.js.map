{
  "version": 3,
  "sources": ["../../src/cli/parseCli.ts"],
  "sourcesContent": ["import fs, { accessSync } from \"node:fs\";\r\nimport * as path from \"node:path\";\r\nimport * as process from \"node:process\";\r\nimport type * as yargs from \"yargs\";\r\nimport { DEFAULT_EXCLUDED_PATH } from \"../const.js\";\r\nimport { getEncodingCharset } from \"../fs/fs\";\r\nimport type { Args, DomainType, MakeJsonArgs, PotHeaders } from \"../types.js\";\r\nimport { stringstring } from \"../utils/common.js\";\r\n\r\n/**\r\n * This function checks if the current working directory is a theme or plugin\r\n * @param currentPath The current working directory\r\n * @param slug The slug of the theme or plugin\r\n */\r\nfunction isThemeOrPlugin(currentPath = \"/\", slug = \"default\"): DomainType {\r\n\tconst currentWorkingDirectory = currentPath;\r\n\r\n\t/**\r\n\t * Checks if the current working directory contains a plugin file\r\n\t */\r\n\ttry {\r\n\t\taccessSync(\r\n\t\t\tpath.join(currentWorkingDirectory, `${slug}.php`),\r\n\t\t\tfs.constants.R_OK,\r\n\t\t);\r\n\t\treturn \"plugin\";\r\n\t} catch (_err) {\r\n\t\t// do nothing\r\n\t\tconsole.log(\r\n\t\t\t`the current working directory ${currentWorkingDirectory} does not contain a ${slug}.php file`,\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Checks if the current working directory contains a style.css file and is a theme\r\n\t */\r\n\ttry {\r\n\t\taccessSync(\r\n\t\t\tpath.join(currentWorkingDirectory, \"style.css\"),\r\n\t\t\tfs.constants.R_OK,\r\n\t\t);\r\n\t\treturn \"theme\";\r\n\t} catch (_err) {\r\n\t\t// do nothing\r\n\t\tconsole.log(\r\n\t\t\t`the current working directory ${currentWorkingDirectory} does not contain a style.css file`,\r\n\t\t);\r\n\t}\r\n\r\n\t// If none of the above conditions are met, return \"generic\"\r\n\treturn \"generic\";\r\n}\r\n\r\n/**\r\n * Parses the command line arguments and returns an object with the parsed values.\r\n *\r\n * @param {{_: string[]}} args - The command line arguments to be parsed.\r\n * @return {object} - An object with the parsed values from the command line arguments.\r\n */\r\nexport function parseCliArgs(\r\n\targs: yargs.PositionalOptions & yargs.Options & yargs.Arguments,\r\n): Args {\r\n\t// Get the input and output paths\r\n\tconst pos1: string | undefined = args._[0]?.toString();\r\n\tconst pos2: string = args._[1]?.toString() || \"languages\";\r\n\r\n\tconst inputPath: string | undefined = pos1 ?? \".\";\r\n\t// remove \"/\" if the output path starts with it\r\n\tconst outputPath: string = pos2.startsWith(\"/\") ? pos2.slice(1) : pos2;\r\n\r\n\t// Store the current working directory\r\n\tconst currentWorkingDirectory = process.cwd();\r\n\r\n\t// Get the slug or use the basename of the current working directory\r\n\t// the slug is the plugin or theme slug. Defaults to the source directory\u2019s basename\r\n\tconst slug =\r\n\t\targs.slug && typeof args.slug === \"string\"\r\n\t\t\t? args.slug\r\n\t\t\t: path.basename(path.resolve(currentWorkingDirectory, inputPath));\r\n\r\n\t// Get the relative paths\r\n\tconst cwd = path.relative(currentWorkingDirectory, inputPath);\r\n\tconst out = path.relative(currentWorkingDirectory, outputPath);\r\n\r\n\t/** get the domain to look for (plugin, theme, etc) */\r\n\tif (!(args?.domain as DomainType)) {\r\n\t\targs.domain = isThemeOrPlugin(path.resolve(cwd), slug);\r\n\t} else {\r\n\t\tswitch (args.domain) {\r\n\t\t\tcase \"plugin\":\r\n\t\t\tcase \"theme\":\r\n\t\t\tcase \"block\":\r\n\t\t\tcase \"theme-block\":\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tconsole.error(\r\n\t\t\t\t\t`Invalid domain: ${args.domain}. Valid domains are: plugin, theme, block, theme-block, generic`,\r\n\t\t\t\t);\r\n\t\t\t\t// fallback to generic if the domain is invalid\r\n\t\t\t\targs.domain = \"generic\";\r\n\t\t}\r\n\t}\r\n\r\n\t// Collect the headers passed via cli\r\n\tconst headers = {};\r\n\tfor (const header of args.headers) {\r\n\t\tconst [key, value] = header.split(\":\") as Record<PotHeaders, string>;\r\n\t\theaders[key.trim()] = value.trim();\r\n\t}\r\n\r\n\tconst parsedArgs: Args = {\r\n\t\tslug: slug,\r\n\t\tdebug: !!args.debug,\r\n\t\tdomain: args.domain as DomainType,\r\n\t\tpaths: { cwd: cwd, out: out },\r\n\t\toptions: {\r\n\t\t\tignoreDomain: !!args?.ignoreDomain,\r\n\t\t\tpackageName: String(args.packageName),\r\n\t\t\tsilent: args.silent === true, // default is false\r\n\t\t\tjson: !!args.json,\r\n\t\t\tlocation: !!args?.location,\r\n\t\t\theaders: headers as Record<PotHeaders, string>,\r\n\t\t\ttheme: !!args?.theme,\r\n\t\t\toutput: !!args?.output,\r\n\t\t\tfileComment: args.fileComment ? String(args.fileComment) : undefined,\r\n\t\t\tcharset: getEncodingCharset(args?.charset as string | undefined),\r\n\t\t\tskip: {\r\n\t\t\t\tjs: !!args.skipJs,\r\n\t\t\t\tphp: !!args.skipPhp,\r\n\t\t\t\tblade: !!args.skipBlade,\r\n\t\t\t\tblockJson: !!args.skipBlockJson,\r\n\t\t\t\tthemeJson: !!args.skipThemeJson,\r\n\t\t\t\taudit: !!args.skipAudit,\r\n\t\t\t},\r\n\t\t\ttranslationDomains: args.translationDomains\r\n\t\t\t\t? Array.isArray(args.translationDomains)\r\n\t\t\t\t\t? args.translationDomains.map(String)\r\n\t\t\t\t\t: [String(args.translationDomains)]\r\n\t\t\t\t: undefined,\r\n\t\t},\r\n\t\t// Patterns\r\n\t\tpatterns: {\r\n\t\t\tmergePaths: stringstring(args.mergePaths as string),\r\n\t\t\tsubtractPaths: stringstring(args.subtractPaths as string),\r\n\t\t\tsubtractAndMerge: !!args.subtractAndMerge,\r\n\t\t\tinclude: stringstring(args.include as string),\r\n\t\t\texclude: [\r\n\t\t\t\t...stringstring(args.exclude as string),\r\n\t\t\t\t...DEFAULT_EXCLUDED_PATH,\r\n\t\t\t],\r\n\t\t},\r\n\t};\r\n\r\n\tparsedArgs.paths.root = args.root ? String(args.root) : undefined;\r\n\r\n\treturn parsedArgs;\r\n}\r\n\r\n/**\r\n * Parses the command line arguments for the JSON command.\r\n * @param args - The command line arguments to be parsed.\r\n */\r\nexport function parseJsonArgs(\r\n\targs: yargs.PositionalOptions & yargs.Options & yargs.Arguments,\r\n): MakeJsonArgs {\r\n\t// Get the input and output paths\r\n\tconst inputPath: string = (args._[0] as string) || \"build\";\r\n\tconst outputPath: string = (args._[1] as string) || \"languages\";\r\n\tconst currentWorkingDirectory = process.cwd();\r\n\tconst slug = path.basename(path.resolve(currentWorkingDirectory));\r\n\r\n\tlet scriptName: string;\r\n\tif (args.scriptName) {\r\n\t\tscriptName = args.scriptName.split(\",\").map((s) => s.trim());\r\n\t\tif (scriptName.length === 1) {\r\n\t\t\tscriptName = scriptName[0];\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\ttimeStart: Date.now(),\r\n\t\tslug,\r\n\t\tsource: inputPath,\r\n\t\tdestination: outputPath,\r\n\t\tscriptName,\r\n\t\tallowedFormats: args.allowedFormats as string[],\r\n\t\tpurge: !!args.purge,\r\n\t\tstripUnused: !!args.stripUnused,\r\n\t\tprettyPrint: !!args.prettyPrint,\r\n\t\tdebug: !!args.debug,\r\n\t\tpaths: {\r\n\t\t\tcwd: currentWorkingDirectory,\r\n\t\t\tout: path.join(currentWorkingDirectory, outputPath),\r\n\t\t},\r\n\t};\r\n}\r\n"],
  "mappings": "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",
  "names": ["fs"]
}
